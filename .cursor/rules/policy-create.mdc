# Kyverno Policy Creation Guidelines

**IMPORTANT: Before creating any policy, always ask the user ONE question at a time. Start with the first question and wait for the answer before proceeding to the next.**

**Agent Instructions: You MUST dynamically discover resources in the cluster based on the user's requirements. Use kubectl commands to find ALL available resources and check which ones have the relevant field structure. Do not make assumptions about what resources exist.**

**üö® CRITICAL: When user says "ALL", "comprehensive", "complete", or "critical" - DO NOT SUGGEST SUBSETS. DO THE COMPLETE WORK IMMEDIATELY. No shortcuts, no "common cases", no lazy behavior. Enumerate every single resource that matches their criteria.**

**ALWAYS create validation policies only.**

**Ask these questions in order (one at a time):**

1. **"What specific behavior or constraint should this policy enforce?"** (What should it check for or prevent?)

2. **Dynamically discover and suggest relevant resources based on their requirement:**
   - **Analyze their constraint** to understand what field/capability they're targeting:
     - Container images ‚Üí Look for resources with `.spec.containers[].image`, `.spec.template.spec.containers[].image`
     - Resource limits ‚Üí Look for resources with `.spec.containers[].resources`, `.spec.template.spec.containers[].resources`
     - Labels/annotations ‚Üí Look for resources with `.metadata.labels`, `.metadata.annotations`
     - Storage ‚Üí Look for resources with `.spec.volumes`, `.spec.volumeClaimTemplates`, `.spec.persistentVolumeClaimRetentionPolicy`
     - Networking ‚Üí Look for resources with `.spec.ports`, `.spec.selector`, `.spec.rules`
     - Security ‚Üí Look for resources with `.spec.securityContext`, `.spec.serviceAccountName`, `.spec.imagePullSecrets`
     - Custom fields ‚Üí Look for any field path they specify
   - **Query the cluster** to discover ALL available resources:
     ```bash
     kubectl api-resources --verbs=list -o name
     ```
   - **Programmatically check** which resources actually have the relevant field structure by sampling existing resources or checking OpenAPI schemas
   - **VALIDATION STEP**: Before creating the policy, use `kubectl explain` to verify field structure for EVERY resource you plan to include
   - **Present complete findings**: "I found [X] resources in your cluster that have the relevant field structure: [complete list]"
   - **If user said "ALL"**: Include every single matching resource immediately. Do NOT ask for subsets.
   - **If user didn't specify scope**: Ask "Should the policy target all of them or a subset?"
   - **Include both native and custom resources** (CRDs, operators, etc.) that match the field criteria
   
   **üîç COMPREHENSIVE DISCOVERY COMMANDS:**
   ```bash
   # Get all resource types and their Kind names
   kubectl api-resources | grep "target-service" | awk '{print $NF}'
   
   # Verify field structure for each resource type
   kubectl explain resource.spec.targetField --recursive | grep targetField
   
   # Count total resources to ensure complete coverage
   kubectl api-resources | grep "target-service" | wc -l
   ```

3. **"Are there any exceptions or special cases to consider?"** (Should it exclude certain namespaces, labels, etc.?)

4. **"How should this policy handle namespace exclusions?"** 
   
   **FIRST: Discover existing namespaces in the cluster:**
   ```bash
   # Get all namespaces with labels and age for analysis
   kubectl get namespaces -o wide --show-labels
   
   # Categorize namespaces by type
   kubectl get namespaces -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,LABELS:.metadata.labels
   
   # Count total namespaces for coverage calculation
   kubectl get namespaces --no-headers | wc -l
   ```
   
   **Analyze the discovered namespaces and categorize them:**
   - **System namespaces**: `kube-system`, `kube-public`, `kube-node-lease`, `kube-node-lease`
   - **Platform namespaces**: Look for `crossplane-system`, `upbound-system`, `cert-manager`, `ingress-nginx`, `monitoring`, `logging`, etc.
   - **Application namespaces**: User workload namespaces (usually without `kube-` or `-system` suffixes)
   - **Special namespaces**: Any with special labels or purposes
   
   **Then choose from these numbered options based on your findings:**
   
   **1. No exclusions** - Apply policy to ALL [X] namespaces discovered
      - Most restrictive approach
      - Enforces consistency across entire cluster
      - Use when: Policy is essential for security/compliance
   
   **2. Exclude system namespaces only** ‚≠ê **RECOMMENDED** ‚≠ê
      - Excludes: [List the actual system namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Balances security with operational stability
      - Use when: Policy targets user workloads but shouldn't break cluster components
   
   **3. Exclude system + platform namespaces**
      - Excludes: [List actual system + platform namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Allows platform tools to operate freely
      - Use when: Policy might conflict with platform operator requirements
   
   **4. Include only specific namespaces**
      - Apply policy only to explicitly listed namespaces from: [list discovered application namespaces]
      - Most targeted approach
      - Use when: Policy is experimental or environment-specific
   
   **5. Custom exclusion list**
      - User-defined list of namespaces to exclude from: [list all discovered namespaces]
      - Use when: Specific applications need exemptions
   
   **üí° Dynamic Platform Engineering Recommendation:**
   Based on the discovered namespaces, provide a specific recommendation with exact counts and coverage percentages. Typically **Option 2** is recommended as it maintains platform stability while enforcing governance on user workloads.

**After Policy Creation:**
1. **MANDATORY VALIDATION**: Before asking about testing, verify your policy actually covers what the user requested:
   - If user said "ALL" resources: Count and list exactly how many resource types you included
   - Compare against your discovery results to ensure 100% coverage
   - If you missed any resources, immediately update the policy - do NOT wait for user to catch your mistake
   
2. **Coverage Report**: Provide a clear summary:
   - "Your policy now covers [X]/[Y] resource types ([Z]% coverage)"
   - "Previously covered: [old count], Now covered: [new count]"
   - List any resource types excluded and why
   
3. **ALWAYS ask: "Would you like to test the policy?"**
   - If yes, perform both positive and negative test cases
   - After testing, ALWAYS clean up test resources (namespaces, deployments, etc.)
   - Show clear test results and explain what was tested

## üö´ ANTI-PATTERNS TO AVOID

**Never do these lazy behaviors:**
- ‚ùå Creating policies with "common" or "popular" resource subsets when user wants ALL
- ‚ùå Suggesting "this covers most use cases" when comprehensive coverage was requested  
- ‚ùå Making partial policies and waiting for user to notice gaps
- ‚ùå Using "efficient" shortcuts instead of complete enumeration
- ‚ùå Assuming 5-10 resource types are "sufficient" when 100+ exist
- ‚ùå Asking "do you want all or a subset?" when user already said ALL

**When user says "ALL", "complete", "comprehensive", or "critical":**
- ‚úÖ Discover every single matching resource type
- ‚úÖ Include every resource in the policy immediately  
- ‚úÖ Validate 100% coverage before presenting results
- ‚úÖ Show exact counts and percentages
- ‚úÖ Fix gaps immediately without being asked

When creating Kyverno policies, follow these platform engineering principles:

## Policy Structure
- **ALWAYS create policies in the project root level `policies/` directory**
- Use descriptive names that explain the policy's purpose
- Include clear annotations for categorization and documentation
- Follow the naming pattern: `[action]-[resource]-[constraint]` (e.g., `disallow-latest-tag`, `require-resource-limits`)

## Policy Categories
- **Platform Security**: Image validation, RBAC enforcement, network policies
- **Platform Resources**: Resource limits, CPU/memory constraints, storage policies  
- **Platform Governance**: Label requirements, annotation enforcement, metadata validation

## Best Practices
- Always include both `validate` and `mutate` rules where appropriate
- Use `background: true` for policies that should run continuously
- Include proper failure messages that guide developers to fix issues
- Test policies with both positive and negative test cases
- Use `exclude` rules to avoid conflicts with system namespaces

## Example Policy Structure
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: policy-name
  annotations:
    policies.kyverno.io/category: Platform Security
    policies.kyverno.io/description: "Brief description of what this policy does"
spec:
  background: true
  rules:
  - name: rule-name
    match:
      resources:
        kinds:
        - Deployment
    validate:
      message: "Clear error message explaining the violation"
      pattern:
        # validation pattern here
```

## Common Policy Patterns

### Container Image Validation (Multiple Resource Types)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag
  annotations:
    policies.kyverno.io/category: Platform Security
spec:
  background: true
  rules:
  - name: check-image-tag-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
        - CronJob
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"
  - name: check-image-tag-pods
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          containers:
          - image: "!*:latest"
```

### Resource Limits (Dynamic Resource Discovery)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-resource-limits
  annotations:
    policies.kyverno.io/category: Platform Resources
spec:
  background: true
  rules:
  - name: check-resource-limits-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          template:
            spec:
              containers:
              - resources:
                  limits:
                    cpu: "?*"
                    memory: "?*"
  - name: check-resource-limits-cronjobs
    match:
      resources:
        kinds:
        - CronJob
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          jobTemplate:
            spec:
              template:
                spec:
                  containers:
                  - resources:
                      limits:
                        cpu: "?*"
                        memory: "?*"
```

### Universal Label Requirements (All Resources)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-required-labels
    match:
      resources:
        kinds:
        - "*"  # Apply to all resource types
    validate:
      message: "Required labels 'app' and 'environment' must be present"
      pattern:
        metadata:
          labels:
            app: "?*"
            environment: "?*"
```

### Custom Resource Policy Example
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: validate-custom-resource
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-custom-field
    match:
      resources:
        kinds:
        - serving.knative.dev/v1/Service  # Example: Knative Service
    validate:
      message: "Custom field validation failed"
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"  # Same validation for custom resources
```

## Testing Your Policies
Create test files in `tests/e2e/policies/` following this pattern:
```yaml
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: policy-name-test
spec:
  steps:
  - name: should-pass-valid-resource
    apply:
      file: valid-resource.yaml
  - name: should-fail-invalid-resource
    apply:
      file: invalid-resource.yaml
    assert:
      - file: expected-error.yaml
```

**Test Cleanup:**
- ALWAYS clean up test resources after testing
- Remove test namespaces: `kubectl delete namespace <test-namespace>`
- Remove test deployments: `kubectl delete deployment <test-deployment> -n <namespace>`
- Verify cleanup: `kubectl get all -n <test-namespace>`

**File Organization:**
- Policies: `policies/[policy-name].yaml`

## Dynamic Resource Discovery Commands

**üî• CRITICAL: Run discovery commands in PARALLEL for efficiency:**

```bash
# Discover all available resources in the cluster
kubectl api-resources --verbs=list -o name

# Get exact Kind names for policy creation
kubectl api-resources | grep "target-service" | awk '{print $NF}' | sort

# Count total resources for validation
kubectl api-resources | grep "target-service" | wc -l

# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -i storage
kubectl api-resources --verbs=list -o wide | grep -i network

# Check resource schemas for specific fields (run multiple in parallel)
kubectl explain deployment.spec.template.spec.containers &
kubectl explain service.spec.ports &
kubectl explain customresource.spec --recursive &

# Sample existing resources to understand field structures
kubectl get deployments -o yaml | head -50
kubectl get services -o yaml | head -50
kubectl get <custom-resource> -o yaml | head -50

# Validate field existence across multiple resource types (parallel)
kubectl explain resource1.spec.targetField --recursive | grep targetField &
kubectl explain resource2.spec.targetField --recursive | grep targetField &
kubectl explain resource3.spec.targetField --recursive | grep targetField &
wait  # Wait for all parallel commands to complete
```

**üìã DISCOVERY VALIDATION CHECKLIST:**
- [ ] Enumerated ALL resources of target type  
- [ ] Verified field structure for each resource type
- [ ] Counted total resources vs policy coverage
- [ ] Included both core and custom resources
- [ ] No lazy shortcuts or "common case" assumptions

## Policy Validation Commands
```bash
# Test a policy against a resource
kubectl apply -f your-policy.yaml
kubectl apply -f test-resource.yaml

# Check policy status
kubectl get clusterpolicies
kubectl describe clusterpolicy your-policy-name

# Validate policy syntax
kyverno validate policy your-policy.yaml

# Test policy against existing resources
kyverno apply your-policy.yaml --resource existing-resource.yaml

# Run Chainsaw tests
cd tests/e2e && chainsaw test policies/
```

Remember: Policies should enforce platform guardrails while providing clear guidance to developers on how to comply.

## üéØ FINAL VALIDATION BEFORE COMPLETION

Before presenting any policy to the user, ask yourself:

1. **Did I discover ALL matching resources?** (Not just common ones)
2. **Did I validate field structure for EVERY resource type?**  
3. **Does my policy coverage match the user's explicit request?**
4. **If user said "ALL" - did I include 100% of discovered resources?**
5. **Can I provide exact counts and percentages of coverage?**

**If ANY answer is "no" - FIX THE POLICY IMMEDIATELY. Don't wait for the user to catch your mistakes.**

**‚úÖ SUCCESS CRITERIA:**
- User said "ALL" ‚Üí Policy includes every matching resource (100% coverage)
- User said "comprehensive" ‚Üí No shortcuts, complete enumeration
- User said "critical" ‚Üí Bulletproof coverage, no gaps
- Policy ready ‚Üí Validated, tested, complete

description:
globs:
alwaysApply: false
---
