# Kyverno Policy Creation Guidelines

**IMPORTANT: Before creating any policy, always ask the user ONE question at a time. Start with the first question and wait for the answer before proceeding to the next.**

**Agent Instructions: You MUST dynamically discover resources in the cluster based on the user's requirements. Use kubectl commands to find ALL available resources and check which ones have the relevant field structure. Do not make assumptions about what resources exist.**

**üö® CRITICAL: When user says "ALL", "comprehensive", "complete", or "critical" - DO NOT SUGGEST SUBSETS. DO THE COMPLETE WORK IMMEDIATELY. No shortcuts, no "common cases", no lazy behavior. Enumerate every single resource that matches their criteria.**

**ALWAYS create validation policies only.**

**Ask these questions in order (one at a time):**

1. **"What specific behavior or constraint should this policy enforce?"** (What should it check for or prevent?)

2. **Dynamically discover and suggest relevant resources based on their requirement:**
   - **Analyze their constraint** to understand what field/capability they're targeting:
     - Container images ‚Üí Look for resources with `.spec.containers[].image`, `.spec.template.spec.containers[].image`
     - Resource limits ‚Üí Look for resources with `.spec.containers[].resources`, `.spec.template.spec.containers[].resources`
     - Labels/annotations ‚Üí Look for resources with `.metadata.labels`, `.metadata.annotations`
     - Storage ‚Üí Look for resources with `.spec.volumes`, `.spec.volumeClaimTemplates`, `.spec.persistentVolumeClaimRetentionPolicy`
     - Networking ‚Üí Look for resources with `.spec.ports`, `.spec.selector`, `.spec.rules`
     - Security ‚Üí Look for resources with `.spec.securityContext`, `.spec.serviceAccountName`, `.spec.imagePullSecrets`
     - Custom fields ‚Üí Look for any field path they specify
   - **Query the cluster** to discover ALL available resources:
     ```bash
     kubectl api-resources --verbs=list -o name
     ```
   - **Programmatically check** which resources actually have the relevant field structure by sampling existing resources or checking OpenAPI schemas
   - **VALIDATION STEP**: Before creating the policy, use `kubectl explain` to verify field structure for EVERY resource you plan to include
   - **Present complete findings**: "I found [X] resources in your cluster that have the relevant field structure: [complete list]"
   - **If user said "ALL"**: Include every single matching resource immediately. Do NOT ask for subsets.
   - **If user didn't specify scope**: Ask "Should the policy target all of them or a subset?"
   - **Include both native and custom resources** (CRDs, operators, etc.) that match the field criteria
   
   **üîç COMPREHENSIVE DISCOVERY COMMANDS:**
   ```bash
   # Get all resource types and their Kind names
   kubectl api-resources | grep "target-service" | awk '{print $NF}'
   
   # Verify field structure for each resource type
   kubectl explain resource.spec.targetField --recursive | grep targetField
   
   # Count total resources to ensure complete coverage
   kubectl api-resources | grep "target-service" | wc -l
   ```

3. **"Are there any exceptions or special cases to consider?"** (Should it exclude certain namespaces, labels, etc.?)

4. **"How should this policy handle namespace exclusions?"** 
   
   **FIRST: Discover existing namespaces in the cluster:**
   ```bash
   # Get all namespaces with labels and age for analysis
   kubectl get namespaces -o wide --show-labels
   
   # Categorize namespaces by type
   kubectl get namespaces -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,LABELS:.metadata.labels
   
   # Count total namespaces for coverage calculation
   kubectl get namespaces --no-headers | wc -l
   ```
   
   **Analyze the discovered namespaces and categorize them:**
   - **System namespaces**: `kube-system`, `kube-public`, `kube-node-lease`, `kube-node-lease`
   - **Platform namespaces**: Look for `crossplane-system`, `upbound-system`, `cert-manager`, `ingress-nginx`, `monitoring`, `logging`, etc.
   - **Application namespaces**: User workload namespaces (usually without `kube-` or `-system` suffixes)
   - **Special namespaces**: Any with special labels or purposes
   
   **Then choose from these numbered options based on your findings:**
   
   **1. No exclusions** - Apply policy to ALL [X] namespaces discovered
      - Most restrictive approach
      - Enforces consistency across entire cluster
      - Use when: Policy is essential for security/compliance
   
   **2. Exclude system namespaces only** ‚≠ê **RECOMMENDED** ‚≠ê
      - Excludes: [List the actual system namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Balances security with operational stability
      - Use when: Policy targets user workloads but shouldn't break cluster components
   
   **3. Exclude system + platform namespaces**
      - Excludes: [List actual system + platform namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Allows platform tools to operate freely
      - Use when: Policy might conflict with platform operator requirements
   
   **4. Include only specific namespaces**
      - Apply policy only to explicitly listed namespaces from: [list discovered application namespaces]
      - Most targeted approach
      - Use when: Policy is experimental or environment-specific
   
   **5. Custom exclusion list**
      - User-defined list of namespaces to exclude from: [list all discovered namespaces]
      - Use when: Specific applications need exemptions
   
   **üí° Dynamic Platform Engineering Recommendation:**
   Based on the discovered namespaces, provide a specific recommendation with exact counts and coverage percentages. Typically **Option 2** is recommended as it maintains platform stability while enforcing governance on user workloads.

**After Policy Creation:**
1. **MANDATORY VALIDATION**: Before asking about testing, verify your policy actually covers what the user requested:
   - If user said "ALL" resources: Count and list exactly how many resource types you included
   - Compare against your discovery results to ensure 100% coverage
   - If you missed any resources, immediately update the policy - do NOT wait for user to catch your mistake
   
2. **Coverage Report**: Provide a clear summary:
   - "Your policy now covers [X]/[Y] resource types ([Z]% coverage)"
   - "Previously covered: [old count], Now covered: [new count]"
   - List any resource types excluded and why
   
3. **ALWAYS ask: "Would you like to test the policy?"**
   - If yes, perform COMPREHENSIVE testing following the mandatory test matrix below
   - After testing, ALWAYS clean up test resources (namespaces, deployments, etc.)
   - Show clear test results and explain what was tested

## üß™ MANDATORY COMPREHENSIVE TESTING MATRIX

**CRITICAL REQUIREMENT**: You MUST test EVERY policy mechanism used. Each different policy type and validation method requires specific test approaches.

### **STEP 0: CLASSIFY YOUR POLICY TYPE**

Before testing, identify what your policy actually does:
- üõ°Ô∏è **Validation Policy**: Allows/blocks resources based on criteria
- üîß **Mutation Policy**: Modifies resources before creation (adds/changes fields)
- üèóÔ∏è **Generation Policy**: Creates additional resources automatically
- üîÑ **Background Policy**: Continuously validates existing resources
- üåê **Webhook Policy**: Uses external validation/mutation services

### **STEP 1: IDENTIFY ALL POLICY MECHANISMS IN YOUR POLICY**

List every mechanism used (regardless of resource type):
- ‚úÖ **Field validation** (any field path: `spec.image`, `metadata.labels.env`, `spec.containers[].resources`)
- ‚úÖ **Pattern matching** (`image: "!*:latest"`, `name: "prod-*"`, `tag: "v[0-9]*"`)
- ‚úÖ **Array/list validation** (all containers, all volumes, all ingress rules)
- ‚úÖ **Conditional logic** (if environment=prod then require X)
- ‚úÖ **Cross-field validation** (service selector must match deployment labels)
- ‚úÖ **Annotation/label requirements** (governance, compliance tagging)
- ‚úÖ **Resource existence checks** (references to ConfigMaps, Secrets, etc.)
- ‚úÖ **CEL expressions** (complex logic, calculations, transformations)
- ‚úÖ **JMESPath queries** (complex field traversal and filtering)
- ‚úÖ **Deny conditions** (blocking specific operations/patterns)
- ‚úÖ **AnyPattern/AllPattern logic** (multiple acceptable alternatives)

### **STEP 2: MANDATORY TESTS BY POLICY TYPE**

**üõ°Ô∏è VALIDATION POLICY TESTS:**
- ‚úÖ **Positive**: Compliant resources ‚Üí ALLOWED (verify creation with `kubectl get`)
- ‚ùå **Negative**: Non-compliant resources ‚Üí BLOCKED (verify rejection, not creation)
- üîç **Edge cases**: Boundary values, empty fields, null values, special characters

**üîß MUTATION POLICY TESTS:**
- ‚úÖ **Mutation Success**: Resource modified correctly ‚Üí VERIFY ACTUAL CHANGES
- ‚úÖ **Mutation Idempotent**: Already-correct resource ‚Üí NO UNWANTED CHANGES  
- ‚ùå **Mutation Failure**: Invalid mutation ‚Üí VERIFY ERROR HANDLING
- üîç **Edge cases**: Missing fields, conflicting values, complex nested structures

**üèóÔ∏è GENERATION POLICY TESTS:**
- ‚úÖ **Generation Success**: Trigger resource ‚Üí VERIFY ALL GENERATED RESOURCES EXIST
- ‚úÖ **Generation Idempotent**: Re-apply trigger ‚Üí NO DUPLICATE RESOURCES
- ‚ùå **Generation Failure**: Invalid trigger ‚Üí VERIFY CLEAN ERROR STATE
- üîç **Edge cases**: Missing dependencies, circular references, resource conflicts

**üîÑ BACKGROUND POLICY TESTS:**
- ‚úÖ **Continuous Validation**: Create non-compliant resource ‚Üí VERIFY ONGOING ENFORCEMENT
- ‚úÖ **Resource Updates**: Modify existing resource ‚Üí VERIFY POLICY STILL APPLIES
- ‚ùå **Policy Violation**: Break compliance ‚Üí VERIFY DETECTION AND ACTION
- üîç **Edge cases**: Large scale, performance impact, race conditions

**üåê WEBHOOK POLICY TESTS:**
- ‚úÖ **Webhook Available**: Normal operations ‚Üí VERIFY EXPECTED BEHAVIOR
- ‚ùå **Webhook Unavailable**: Network/service issues ‚Üí VERIFY FALLBACK BEHAVIOR
- ‚è±Ô∏è **Webhook Timeout**: Slow responses ‚Üí VERIFY TIMEOUT HANDLING
- üîç **Edge cases**: Malformed responses, authentication failures, rate limiting

### **STEP 3: UNIVERSAL MECHANISM VERIFICATION**

**CRITICAL**: For each policy mechanism, you must verify:
- ‚úÖ **Field paths exist** (use `kubectl explain <resource>.spec.fieldPath` for verification)
- ‚úÖ **Pattern matching accuracy** (test valid patterns, invalid patterns, edge cases)
- ‚úÖ **Array/list logic** (empty arrays, single items, multiple items, invalid items)
- ‚úÖ **Conditional logic flow** (all branches, edge conditions, nested conditions)
- ‚úÖ **Cross-resource references** (valid refs, invalid refs, missing refs, circular refs)
- ‚úÖ **CEL/JMESPath expressions** (valid syntax, correct results, error handling)
- ‚úÖ **Performance impact** (large resources, complex queries, bulk operations)
- ‚úÖ **Error messages clarity** (actionable guidance for each failure mode)

### **STEP 4: RESOURCE CAPABILITY DISCOVERY & TESTING**

**CAPABILITY-BASED DISCOVERY** (not just name-based):
```bash
# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -E "(namespaced|cluster-scoped)"

# Resources with container specs (for image/security policies)
for resource in deployment daemonset statefulset job cronjob pod; do
  kubectl explain $resource.spec.containers 2>/dev/null && echo "$resource has containers"
done

# Resources with resource limits (for resource policies)  
for resource in deployment daemonset statefulset job cronjob pod; do
  kubectl explain $resource.spec.containers.resources 2>/dev/null && echo "$resource has resource limits"
done

# Resources with metadata (for label/annotation policies)
kubectl api-resources --verbs=list | awk '{print $1}' | xargs -I {} kubectl explain {}.metadata 2>/dev/null | grep -B1 "labels\|annotations"
```

**CROSS-CAPABILITY TESTING:**
1. **Test ALL resource types** that have the target capability (not just popular ones)
2. **Verify field structure variations** (e.g., `spec.containers` vs `spec.template.spec.containers`)
3. **Test mixed scenarios** (valid + invalid resources in same operation)
4. **Confirm scope exclusions** (namespaces, labels, resource types) work correctly
5. **Test resource relationships** (Services ‚Üí Deployments, ConfigMaps ‚Üí Pods, etc.)

### **STEP 5: UNIVERSAL POST-TEST VALIDATION CHECKLIST**

**POLICY BEHAVIOR VERIFICATION:**
- [ ] **Every policy mechanism has appropriate test cases** (by policy type)
- [ ] **Actual behavior matches expected behavior** (validation/mutation/generation/background)
- [ ] **Resource state verification** (created/blocked/modified/generated as expected)
- [ ] **Error handling robustness** (failures produce clear, actionable messages)
- [ ] **Policy scope accuracy** (covers requested resources, excludes intended exceptions)

**SECURITY & RELIABILITY VERIFICATION:**
- [ ] **No false positives** (correct resources inappropriately affected)
- [ ] **No false negatives** (incorrect resources inappropriately allowed)
- [ ] **No bypass mechanisms** (overly permissive patterns, logic holes)
- [ ] **Performance acceptable** (policy doesn't significantly impact cluster operations)
- [ ] **Edge case handling** (empty values, null fields, malformed data)

### **STEP 6: MANDATORY CLEANUP & VERIFICATION** üßπ

**üö® CRITICAL: TESTING IS NOT COMPLETE UNTIL CLEANUP IS VERIFIED üö®**

**CLEANUP REQUIREMENTS:**
```bash
# 1. Remove ALL test namespaces
kubectl get namespaces | grep "test\|policy-test"
kubectl delete namespace <list-all-test-namespaces>

# 2. Remove ALL test files  
ls test-*.yaml 2>/dev/null && rm -f test-*.yaml
ls *test*.yaml 2>/dev/null && rm -f *test*.yaml

# 3. Verify cluster is clean
kubectl get all -A | grep -E "(test|policy-test)" || echo "‚úÖ Cluster clean"

# 4. Verify filesystem is clean  
ls test-* 2>/dev/null || echo "‚úÖ Files clean"
```

**CLEANUP VERIFICATION CHECKLIST:**
- [ ] **All test namespaces removed** (verified with `kubectl get namespaces`)
- [ ] **All test files removed** (verified with `ls test-*`)
- [ ] **No test resources in cluster** (verified with `kubectl get all -A | grep test`)
- [ ] **Cluster returned to original state** (no artifacts from testing remain)

**‚ùå DO NOT MARK TESTING COMPLETE WITHOUT CLEANUP VERIFICATION ‚ùå**

**If cleanup fails:**
- Document what couldn't be cleaned up and why
- Provide manual cleanup instructions for next operator
- Mark testing as "INCOMPLETE" until cleanup is resolved

## üö® UNIVERSAL TESTING ANTI-PATTERNS

**Policy-Type-Agnostic Mistakes:**
- ‚ùå **Testing only happy path** (works for validation, mutation, generation, background)
- ‚ùå **Assuming behavior without verification** (applies to all policy types)
- ‚ùå **Testing only popular resource types** (missing edge cases across all policies)
- ‚ùå **Not verifying actual state changes** (critical for mutation/generation policies)
- ‚ùå **Ignoring performance impact** (especially critical for background policies)
- ‚ùå **Skipping error condition testing** (essential for webhook/external policies)

**Logic & Pattern Mistakes:**
- ‚ùå **Overly permissive patterns** (`metadata.name: "?*"`, `spec: "?*"`)
- ‚ùå **Wrong field path assumptions** (not using `kubectl explain` to verify)
- ‚ùå **Incomplete array/list validation** (testing single items, ignoring edge cases)
- ‚ùå **Missing conditional branch testing** (testing only one path of if/then logic)
- ‚ùå **Placeholder patterns in production** (temporary patterns that become permanent)

**Resource & Scope Mistakes:**
- ‚ùå **Name-based resource discovery only** (missing capability-based discovery)
- ‚ùå **Single API group focus** (ignoring core K8s, CRDs, operators)
- ‚ùå **Namespace scope confusion** (not testing both namespaced and cluster resources)
- ‚ùå **Resource relationship ignorance** (not testing cross-resource impacts)

## üìã TESTING EXECUTION REQUIREMENTS

**When testing policies, follow this sequence:**
1. **Create test resources for positive cases** ‚Üí Verify they are created
2. **Create test resources for negative cases** ‚Üí Verify they are blocked  
3. **Check kubectl get commands** ‚Üí Confirm actual vs expected state
4. **Review error messages** ‚Üí Ensure they guide developers correctly
5. **Test edge cases** ‚Üí Boundary conditions and special scenarios
6. **üßπ MANDATORY CLEANUP** ‚Üí See STEP 6 above for detailed requirements

**‚ö†Ô∏è REMINDER: Steps 1-5 are testing. Step 6 is MANDATORY for completion.**

**Test Documentation Requirements:**
- Document what each test validates
- Show both the command and expected outcome
- Explain why each negative test should fail
- Provide clear success/failure criteria

## üéØ EXAMPLES: PROPER TESTING BY POLICY TYPE

### **Validation Policy Example (Image Security)**
```yaml
# Image security policy: no latest tags, must be from approved registry

‚úÖ POSITIVE TESTS:
- Pod with registry.company.com/app:v1.2.3 ‚Üí ALLOWED
- Deployment with registry.company.com/api:sha256:abc123 ‚Üí ALLOWED

‚ùå NEGATIVE TESTS:  
- Pod with ubuntu:latest ‚Üí BLOCKED
- Deployment with docker.io/app:v1.0 ‚Üí BLOCKED (wrong registry)
```

### **Mutation Policy Example (Resource Defaults)**
```yaml
# Mutation policy: add default resource limits if missing

‚úÖ MUTATION TESTS:
- Pod without limits ‚Üí VERIFY limits added (cpu: 100m, memory: 128Mi)
- Deployment with partial limits ‚Üí VERIFY only missing limits added
- Pod with existing limits ‚Üí VERIFY no changes made
```

### **Generation Policy Example (Service Mesh)**
```yaml
# Generate policy: create ServiceMonitor for services with monitoring=true

‚úÖ GENERATION TESTS:
- Service with monitoring=true ‚Üí VERIFY ServiceMonitor created
- Service without annotation ‚Üí VERIFY no ServiceMonitor created
- Delete Service ‚Üí VERIFY ServiceMonitor cleaned up
```

**UNIVERSAL PRINCIPLE**: Test that your policy does EXACTLY what it claims - no more, no less, regardless of policy type or resource.

## ‚ö†Ô∏è  CRITICAL VALIDATION LOGIC ERRORS TO AVOID

**These validation mistakes create security gaps:**

### üö® **Pattern Validation Errors**
- ‚ùå **Using `metadata.name: "?*"`** (allows everything with any name)
- ‚ùå **Overly permissive patterns** that don't actually restrict anything
- ‚ùå **Wrong field paths** (e.g., `spec.region` when it should be `spec.forProvider.region`)
- ‚ùå **Missing required fields** in validation patterns

### üö® **Logic Flow Errors**  
- ‚ùå **"Allow first, validate later"** approaches that create security holes
- ‚ùå **Changing deny rules to allow rules** without proper validation
- ‚ùå **Assuming validation works** without testing actual blocked resources
- ‚ùå **Placeholder patterns** meant for testing that remain in production policies

### üö® **Multi-Approach Validation Errors**
- ‚ùå **Different validation methods for similar resources** without testing both
- ‚ùå **Inconsistent security levels** between resource types
- ‚ùå **Missing validation** for some resource categories
- ‚ùå **Weak annotation-based controls** that can be easily bypassed

### ‚úÖ **CORRECT APPROACH: Validation Logic Verification**

Before finalizing any policy:
1. **List every validation pattern** used in your policy
2. **Test each pattern** with valid and invalid inputs  
3. **Verify field paths exist** in target resource schemas
4. **Confirm blocked resources are actually blocked**
5. **Ensure error messages guide users to correct solutions**

## üö´ ANTI-PATTERNS TO AVOID

**Never do these lazy behaviors:**
- ‚ùå Creating policies with "common" or "popular" resource subsets when user wants ALL
- ‚ùå Suggesting "this covers most use cases" when comprehensive coverage was requested  
- ‚ùå Making partial policies and waiting for user to notice gaps
- ‚ùå Using "efficient" shortcuts instead of complete enumeration
- ‚ùå Assuming 5-10 resource types are "sufficient" when 100+ exist
- ‚ùå Asking "do you want all or a subset?" when user already said ALL

**When user says "ALL", "complete", "comprehensive", or "critical":**
- ‚úÖ Discover every single matching resource type
- ‚úÖ Include every resource in the policy immediately  
- ‚úÖ Validate 100% coverage before presenting results
- ‚úÖ Show exact counts and percentages
- ‚úÖ Fix gaps immediately without being asked

When creating Kyverno policies, follow these platform engineering principles:

## Policy Structure
- **ALWAYS create policies in the project root level `policies/` directory**
- Use descriptive names that explain the policy's purpose
- Include clear annotations for categorization and documentation
- Follow the naming pattern: `[action]-[resource]-[constraint]` (e.g., `disallow-latest-tag`, `require-resource-limits`)

## Policy Categories
- **Platform Security**: Image validation, RBAC enforcement, network policies
- **Platform Resources**: Resource limits, CPU/memory constraints, storage policies  
- **Platform Governance**: Label requirements, annotation enforcement, metadata validation

## Best Practices
- Always include both `validate` and `mutate` rules where appropriate
- Use `background: true` for policies that should run continuously
- Include proper failure messages that guide developers to fix issues
- Test policies with both positive and negative test cases
- Use `exclude` rules to avoid conflicts with system namespaces

## Example Policy Structure
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: policy-name
  annotations:
    policies.kyverno.io/category: Platform Security
    policies.kyverno.io/description: "Brief description of what this policy does"
spec:
  background: true
  rules:
  - name: rule-name
    match:
      resources:
        kinds:
        - Deployment
    validate:
      message: "Clear error message explaining the violation"
      pattern:
        # validation pattern here
```

## Common Policy Patterns

### Container Image Validation (Multiple Resource Types)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag
  annotations:
    policies.kyverno.io/category: Platform Security
spec:
  background: true
  rules:
  - name: check-image-tag-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
        - CronJob
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"
  - name: check-image-tag-pods
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          containers:
          - image: "!*:latest"
```

### Resource Limits (Dynamic Resource Discovery)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-resource-limits
  annotations:
    policies.kyverno.io/category: Platform Resources
spec:
  background: true
  rules:
  - name: check-resource-limits-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          template:
            spec:
              containers:
              - resources:
                  limits:
                    cpu: "?*"
                    memory: "?*"
  - name: check-resource-limits-cronjobs
    match:
      resources:
        kinds:
        - CronJob
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          jobTemplate:
            spec:
              template:
                spec:
                  containers:
                  - resources:
                      limits:
                        cpu: "?*"
                        memory: "?*"
```

### Universal Label Requirements (All Resources)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-required-labels
    match:
      resources:
        kinds:
        - "*"  # Apply to all resource types
    validate:
      message: "Required labels 'app' and 'environment' must be present"
      pattern:
        metadata:
          labels:
            app: "?*"
            environment: "?*"
```

### Custom Resource Policy Example
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: validate-custom-resource
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-custom-field
    match:
      resources:
        kinds:
        - serving.knative.dev/v1/Service  # Example: Knative Service
    validate:
      message: "Custom field validation failed"
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"  # Same validation for custom resources
```

## Testing Your Policies
Create test files in `tests/e2e/policies/` following this pattern:
```yaml
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: policy-name-test
spec:
  steps:
  - name: should-pass-valid-resource
    apply:
      file: valid-resource.yaml
  - name: should-fail-invalid-resource
    apply:
      file: invalid-resource.yaml
    assert:
      - file: expected-error.yaml
```

**Test Cleanup:**
- ALWAYS clean up test resources after testing
- Remove test namespaces: `kubectl delete namespace <test-namespace>`
- Remove test deployments: `kubectl delete deployment <test-deployment> -n <namespace>`
- Verify cleanup: `kubectl get all -n <test-namespace>`

**File Organization:**
- Policies: `policies/[policy-name].yaml`

## Dynamic Resource Discovery Commands

**üî• CRITICAL: Run discovery commands in PARALLEL for efficiency:**

```bash
# Discover all available resources in the cluster
kubectl api-resources --verbs=list -o name

# Get exact Kind names for policy creation
kubectl api-resources | grep "target-service" | awk '{print $NF}' | sort

# Count total resources for validation
kubectl api-resources | grep "target-service" | wc -l

# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -i storage
kubectl api-resources --verbs=list -o wide | grep -i network

# Check resource schemas for specific fields (run multiple in parallel)
kubectl explain deployment.spec.template.spec.containers &
kubectl explain service.spec.ports &
kubectl explain customresource.spec --recursive &

# Sample existing resources to understand field structures
kubectl get deployments -o yaml | head -50
kubectl get services -o yaml | head -50
kubectl get <custom-resource> -o yaml | head -50

# Validate field existence across multiple resource types (parallel)
kubectl explain resource1.spec.targetField --recursive | grep targetField &
kubectl explain resource2.spec.targetField --recursive | grep targetField &
kubectl explain resource3.spec.targetField --recursive | grep targetField &
wait  # Wait for all parallel commands to complete
```

**üìã DISCOVERY VALIDATION CHECKLIST:**
- [ ] Enumerated ALL resources of target type  
- [ ] Verified field structure for each resource type
- [ ] Counted total resources vs policy coverage
- [ ] Included both core and custom resources
- [ ] No lazy shortcuts or "common case" assumptions

## Policy Validation Commands
```bash
# Test a policy against a resource
kubectl apply -f your-policy.yaml
kubectl apply -f test-resource.yaml

# Check policy status
kubectl get clusterpolicies
kubectl describe clusterpolicy your-policy-name

# Validate policy syntax
kyverno validate policy your-policy.yaml

# Test policy against existing resources
kyverno apply your-policy.yaml --resource existing-resource.yaml

# Run Chainsaw tests
cd tests/e2e && chainsaw test policies/
```

Remember: Policies should enforce platform guardrails while providing clear guidance to developers on how to comply.

## üéØ FINAL VALIDATION BEFORE COMPLETION

Before presenting any policy to the user, ask yourself:

1. **Did I discover ALL matching resources?** (Not just common ones)
2. **Did I validate field structure for EVERY resource type?**  
3. **Does my policy coverage match the user's explicit request?**
4. **If user said "ALL" - did I include 100% of discovered resources?**
5. **Can I provide exact counts and percentages of coverage?**

**If ANY answer is "no" - FIX THE POLICY IMMEDIATELY. Don't wait for the user to catch your mistakes.**

**‚úÖ SUCCESS CRITERIA:**
- User said "ALL" ‚Üí Policy includes every matching resource (100% coverage)
- User said "comprehensive" ‚Üí No shortcuts, complete enumeration
- User said "critical" ‚Üí Bulletproof coverage, no gaps
- Policy ready ‚Üí Validated, tested, complete

## üéØ MANDATORY PRE-COMPLETION CHECKLIST

**Before presenting any policy as "complete," verify ALL of these:**

### **Policy Coverage Verification**
- [ ] Policy covers exact number of resources discovered (e.g., 131/131)
- [ ] No resource types were accidentally excluded
- [ ] All validation approaches are actually restrictive (not permissive)

### **Validation Logic Verification**  
- [ ] Every validation pattern has been tested with valid inputs ‚Üí PASS
- [ ] Every validation pattern has been tested with invalid inputs ‚Üí FAIL  
- [ ] Field paths are correct for each resource type (verified with `kubectl explain`)
- [ ] Error messages provide actionable guidance

### **Test Case Completeness**
- [ ] Positive tests created for each validation approach
- [ ] Negative tests created for each validation approach  
- [ ] Resources in positive tests were actually created successfully
- [ ] Resources in negative tests were actually blocked (not created)
- [ ] Multiple resource types tested from each API group

### **Security Validation**
- [ ] No "allow everything" patterns (e.g., `metadata.name: "?*"`)
- [ ] No overly permissive validation that bypasses security controls
- [ ] Annotation-based validations require specific, verifiable values
- [ ] Deny conditions actually block resource creation when triggered

### **Documentation & Cleanup**
- [ ] Clear explanation of what each validation rule does
- [ ] Test results documented with actual kubectl commands and outputs
- [ ] **ALL test resources cleaned up from cluster** (STEP 6 completed)
- [ ] **Cleanup verification completed** (no test artifacts remain)
- [ ] Policy file saved in correct location (`policies/`)

**üö® CRITICAL: If ANY item above is unchecked, the policy is NOT ready for production.**

**‚ùì SELF-VERIFICATION QUESTIONS:**
1. "If I were an attacker, could I bypass any of these validation rules?"
2. "Do my test results prove the policy actually enforces what I claim?"
3. "Would a developer understand how to fix violations from the error messages?"
4. "Did I test the failure cases as thoroughly as the success cases?"
5. "Did I complete STEP 6 cleanup and verify no test artifacts remain?"

description:
globs:
alwaysApply: false
---
