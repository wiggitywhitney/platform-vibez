# Kyverno Policy Creation Guidelines

**IMPORTANT: Before creating any policy, always ask the user ONE question at a time. Start with the first question and wait for the answer before proceeding to the next.**

**Agent Instructions: You MUST dynamically discover resources in the cluster based on the user's requirements. Use kubectl commands to find ALL available resources and check which ones have the relevant field structure. Do not make assumptions about what resources exist.**

**üö® CRITICAL: When user says "ALL", "comprehensive", "complete", or "critical" - DO NOT SUGGEST SUBSETS. DO THE COMPLETE WORK IMMEDIATELY. No shortcuts, no "common cases", no lazy behavior. Enumerate every single resource that matches their criteria.**

**ALWAYS create validation policies only.**

**Ask these questions in order (one at a time):**

1. **"What specific behavior or constraint should this policy enforce?"** (What should it check for or prevent?)

2. **Comprehensive Schema Analysis (Zero Assumptions Approach):**

   **üö® CRITICAL: NEVER assume resource names, field names, or field structures. Analyze EVERY resource's complete schema.**

   **Phase 1: Enumerate ALL Resources**
   ```bash
   # Get every single resource in the cluster - no filtering by name patterns
   kubectl api-resources --verbs=list -o name > all_resources.txt
   echo "Total resources to analyze: $(wc -l < all_resources.txt)"
   ```

   **Phase 2: Complete Schema Extraction**
   For EVERY SINGLE resource (no exceptions):
   ```bash
   while read resource; do
     echo "=== ANALYZING: $resource ==="
     
     # Extract complete schema recursively
     kubectl explain "$resource" --recursive > "schema_${resource//\//_}.txt" 2>/dev/null || echo "Schema unavailable"
     
     # Extract metadata schema (for annotations, labels)
     kubectl explain "$resource.metadata" --recursive > "metadata_${resource//\//_}.txt" 2>/dev/null || echo "No metadata"
     
     # Extract status schema (constraint info might be in status)
     kubectl explain "$resource.status" --recursive > "status_${resource//\//_}.txt" 2>/dev/null || echo "No status"
     
   done < all_resources.txt
   ```

   **Phase 3: Constraint Evaluation Against Every Schema**
   For each constraint requirement, analyze EVERY resource schema:
   ```bash
   constraint_analysis() {
     local user_constraint="$1"  # e.g., "us-east-1", "approved-registry", "required-label"
     local constraint_type="$2"  # e.g., "region", "image", "label", "annotation"
     
     echo "Analyzing ALL schemas for constraint: $user_constraint (type: $constraint_type)"
     
     # Check every schema file for relevant fields
     for schema_file in schema_*.txt metadata_*.txt status_*.txt; do
       resource_name=$(echo "$schema_file" | sed 's/^[^_]*_//; s/\.txt$//' | tr '_' '/')
       
       echo "--- $resource_name ---"
       
       case "$constraint_type" in
         "region")
           # Look for ANY field that could contain region/zone/location information
           grep -i -E "(region|zone|location|placement|availability|datacenter|geography)" "$schema_file" || echo "No location fields"
           ;;
         "image")
           # Look for ANY field that could contain container images
           grep -i -E "(image|container|registry|repository|tag)" "$schema_file" || echo "No image fields"
           ;;
         "label"|"annotation")
           # Check if resource supports metadata
           grep -E "(labels|annotations)" "$schema_file" || echo "No metadata support"
           ;;
         *)
           # Generic constraint - search for user's exact terms and related concepts
           grep -i "$user_constraint" "$schema_file" || echo "No direct matches"
           # Add semantic analysis for related terms
           ;;
       esac
     done
   }
   ```

   **Phase 4: Sample Real Resources for Field Patterns**
   ```bash
   # For resources that might be relevant, sample actual instances
   sample_resource_fields() {
     local resource="$1"
     
     echo "Sampling real instances of $resource"
     
     # Get sample resources
     kubectl get "$resource" -o yaml --limit=5 2>/dev/null > "sample_${resource//\//_}.yaml"
     
     if [ -s "sample_${resource//\//_}.yaml" ]; then
       echo "Found real instances, analyzing field usage:"
       
       # Extract all field paths and values that match constraint
       grep -i -E "(constraint-pattern)" "sample_${resource//\//_}.yaml" || echo "No constraint values found"
     else
       echo "No real instances found - will validate using schema only"
     fi
   }
   ```

   **Phase 5: Policy Coverage Decision Matrix**
   Create explicit decisions for every resource:
   ```bash
   # Create decision matrix for every resource
   echo "Resource,HasRelevantFields,FieldPaths,ValidationApproach,IncludeInPolicy,Reason" > coverage_matrix.csv
   
   while read resource; do
     # Document decision for each resource based on schema analysis
     echo "Analyzing $resource for inclusion..."
   done < all_resources.txt
   ```

   **üö® ZERO ASSUMPTION PRINCIPLES:**
   1. **Never filter by resource name patterns** - analyze every single resource
   2. **Never assume field names** - extract complete schemas and search semantically  
   3. **Never assume field locations** - check spec, metadata, status, and all nested objects
   4. **Never assume validation approaches** - discover what each resource actually supports
   5. **Always sample real resources** - verify schema understanding with actual data
   6. **Document every decision** - explicit reasoning for include/exclude choices

   **MANDATORY COVERAGE VERIFICATION:**
   - [ ] Every resource in cluster analyzed (0 skipped)
   - [ ] Complete schema extracted for each resource
   - [ ] Constraint relevance evaluated for each resource  
   - [ ] Validation approach determined for each relevant resource
   - [ ] Inclusion decision documented with justification
   - [ ] Total coverage calculated and verified

3. **"Are there any exceptions or special cases to consider?"** (Should it exclude certain namespaces, labels, etc.?)

4. **"How should this policy handle namespace exclusions?"** 
   
   **FIRST: Discover existing namespaces in the cluster:**
   ```bash
   # Get all namespaces with labels and age for analysis
   kubectl get namespaces -o wide --show-labels
   
   # Categorize namespaces by type
   kubectl get namespaces -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,LABELS:.metadata.labels
   
   # Count total namespaces for coverage calculation
   kubectl get namespaces --no-headers | wc -l
   ```
   
   **Analyze the discovered namespaces and categorize them:**
   - **System namespaces**: `kube-system`, `kube-public`, `kube-node-lease`, `kube-node-lease`
   - **Platform namespaces**: Look for `crossplane-system`, `upbound-system`, `cert-manager`, `ingress-nginx`, `monitoring`, `logging`, etc.
   - **Application namespaces**: User workload namespaces (usually without `kube-` or `-system` suffixes)
   - **Special namespaces**: Any with special labels or purposes
   
   **Then choose from these numbered options based on your findings:**
   
   **1. No exclusions** - Apply policy to ALL [X] namespaces discovered
      - Most restrictive approach
      - Enforces consistency across entire cluster
      - Use when: Policy is essential for security/compliance
   
   **2. Exclude system namespaces only** ‚≠ê **RECOMMENDED** ‚≠ê
      - Excludes: [List the actual system namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Balances security with operational stability
      - Use when: Policy targets user workloads but shouldn't break cluster components
   
   **3. Exclude system + platform namespaces**
      - Excludes: [List actual system + platform namespaces found]
      - Covers: [X]/[Y] namespaces ([Z]% coverage)
      - Allows platform tools to operate freely
      - Use when: Policy might conflict with platform operator requirements
   
   **4. Include only specific namespaces**
      - Apply policy only to explicitly listed namespaces from: [list discovered application namespaces]
      - Most targeted approach
      - Use when: Policy is experimental or environment-specific
   
   **5. Custom exclusion list**
      - User-defined list of namespaces to exclude from: [list all discovered namespaces]
      - Use when: Specific applications need exemptions
   
   **üí° Dynamic Platform Engineering Recommendation:**
   Based on the discovered namespaces, provide a specific recommendation with exact counts and coverage percentages. Typically **Option 2** is recommended as it maintains platform stability while enforcing governance on user workloads.

**After Policy Creation:**
1. **MANDATORY VALIDATION**: Before asking about testing, verify your policy actually covers what the user requested:
   - If user said "ALL" resources: Count and list exactly how many resource types you included
   - Compare against your discovery results to ensure 100% coverage
   - If you missed any resources, immediately update the policy - do NOT wait for user to catch your mistake
   
2. **Coverage Report**: Provide a clear summary:
   - "Your policy now covers [X]/[Y] resource types ([Z]% coverage)"
   - "Previously covered: [old count], Now covered: [new count]"
   - List any resource types excluded and why
   
3. **ALWAYS ask: "Would you like to test the policy?"**
   - If yes, perform COMPREHENSIVE testing following the mandatory test matrix below
   - After testing, ALWAYS clean up test resources (namespaces, deployments, etc.)
   - Show clear test results and explain what was tested

## üß™ MANDATORY COMPREHENSIVE TESTING MATRIX

**CRITICAL REQUIREMENT**: You MUST test EVERY policy mechanism used. Each different policy type and validation method requires specific test approaches.

### **STEP 0: CLASSIFY YOUR POLICY TYPE**

Before testing, identify what your policy actually does:
- üõ°Ô∏è **Validation Policy**: Allows/blocks resources based on criteria
- üîß **Mutation Policy**: Modifies resources before creation (adds/changes fields)
- üèóÔ∏è **Generation Policy**: Creates additional resources automatically
- üîÑ **Background Policy**: Continuously validates existing resources
- üåê **Webhook Policy**: Uses external validation/mutation services

### **STEP 1: IDENTIFY ALL POLICY MECHANISMS IN YOUR POLICY**

List every mechanism used (regardless of resource type):
- ‚úÖ **Field validation** (any field path: `spec.image`, `metadata.labels.env`, `spec.containers[].resources`)
- ‚úÖ **Pattern matching** (`image: "!*:latest"`, `name: "prod-*"`, `tag: "v[0-9]*"`)
- ‚úÖ **Array/list validation** (all containers, all volumes, all ingress rules)
- ‚úÖ **Conditional logic** (if environment=prod then require X)
- ‚úÖ **Cross-field validation** (service selector must match deployment labels)
- ‚úÖ **Annotation/label requirements** (governance, compliance tagging)
- ‚úÖ **Resource existence checks** (references to ConfigMaps, Secrets, etc.)
- ‚úÖ **CEL expressions** (complex logic, calculations, transformations)
- ‚úÖ **JMESPath queries** (complex field traversal and filtering)
- ‚úÖ **Deny conditions** (blocking specific operations/patterns)
- ‚úÖ **AnyPattern/AllPattern logic** (multiple acceptable alternatives)

### **STEP 2: MANDATORY TESTS BY POLICY TYPE**

**üõ°Ô∏è VALIDATION POLICY TESTS:**
- ‚úÖ **Positive**: Compliant resources ‚Üí ALLOWED (verify creation with `kubectl get`)
- ‚ùå **Negative**: Non-compliant resources ‚Üí BLOCKED (verify rejection, not creation)
- üîç **Edge cases**: Boundary values, empty fields, null values, special characters

**üîß MUTATION POLICY TESTS:**
- ‚úÖ **Mutation Success**: Resource modified correctly ‚Üí VERIFY ACTUAL CHANGES
- ‚úÖ **Mutation Idempotent**: Already-correct resource ‚Üí NO UNWANTED CHANGES  
- ‚ùå **Mutation Failure**: Invalid mutation ‚Üí VERIFY ERROR HANDLING
- üîç **Edge cases**: Missing fields, conflicting values, complex nested structures

**üèóÔ∏è GENERATION POLICY TESTS:**
- ‚úÖ **Generation Success**: Trigger resource ‚Üí VERIFY ALL GENERATED RESOURCES EXIST
- ‚úÖ **Generation Idempotent**: Re-apply trigger ‚Üí NO DUPLICATE RESOURCES
- ‚ùå **Generation Failure**: Invalid trigger ‚Üí VERIFY CLEAN ERROR STATE
- üîç **Edge cases**: Missing dependencies, circular references, resource conflicts

**üîÑ BACKGROUND POLICY TESTS:**
- ‚úÖ **Continuous Validation**: Create non-compliant resource ‚Üí VERIFY ONGOING ENFORCEMENT
- ‚úÖ **Resource Updates**: Modify existing resource ‚Üí VERIFY POLICY STILL APPLIES
- ‚ùå **Policy Violation**: Break compliance ‚Üí VERIFY DETECTION AND ACTION
- üîç **Edge cases**: Large scale, performance impact, race conditions

**üåê WEBHOOK POLICY TESTS:**
- ‚úÖ **Webhook Available**: Normal operations ‚Üí VERIFY EXPECTED BEHAVIOR
- ‚ùå **Webhook Unavailable**: Network/service issues ‚Üí VERIFY FALLBACK BEHAVIOR
- ‚è±Ô∏è **Webhook Timeout**: Slow responses ‚Üí VERIFY TIMEOUT HANDLING
- üîç **Edge cases**: Malformed responses, authentication failures, rate limiting

### **STEP 3: UNIVERSAL MECHANISM VERIFICATION**

**CRITICAL**: For each policy mechanism, you must verify:
- ‚úÖ **Field paths exist** (use `kubectl explain <resource>.spec.fieldPath` for verification)
- ‚úÖ **Pattern matching accuracy** (test valid patterns, invalid patterns, edge cases)
- ‚úÖ **Array/list logic** (empty arrays, single items, multiple items, invalid items)
- ‚úÖ **Conditional logic flow** (all branches, edge conditions, nested conditions)
- ‚úÖ **Cross-resource references** (valid refs, invalid refs, missing refs, circular refs)
- ‚úÖ **CEL/JMESPath expressions** (valid syntax, correct results, error handling)
- ‚úÖ **Performance impact** (large resources, complex queries, bulk operations)
- ‚úÖ **Error messages clarity** (actionable guidance for each failure mode)

### **STEP 4: RESOURCE CAPABILITY DISCOVERY & TESTING**

**CAPABILITY-BASED DISCOVERY** (not just name-based):
```bash
# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -E "(namespaced|cluster-scoped)"

# Resources with container specs (for image/security policies)
for resource in deployment daemonset statefulset job cronjob pod; do
  kubectl explain $resource.spec.containers 2>/dev/null && echo "$resource has containers"
done

# Resources with resource limits (for resource policies)  
for resource in deployment daemonset statefulset job cronjob pod; do
  kubectl explain $resource.spec.containers.resources 2>/dev/null && echo "$resource has resource limits"
done

# Resources with metadata (for label/annotation policies)
kubectl api-resources --verbs=list | awk '{print $1}' | xargs -I {} kubectl explain {}.metadata 2>/dev/null | grep -B1 "labels\|annotations"
```

**CROSS-CAPABILITY TESTING:**
1. **Test ALL resource types** that have the target capability (not just popular ones)
2. **Verify field structure variations** (e.g., `spec.containers` vs `spec.template.spec.containers`)
3. **Test mixed scenarios** (valid + invalid resources in same operation)
4. **Confirm scope exclusions** (namespaces, labels, resource types) work correctly
5. **Test resource relationships** (Services ‚Üí Deployments, ConfigMaps ‚Üí Pods, etc.)

### **STEP 5: UNIVERSAL POST-TEST VALIDATION CHECKLIST**

**POLICY BEHAVIOR VERIFICATION:**
- [ ] **Every policy mechanism has appropriate test cases** (by policy type)
- [ ] **Actual behavior matches expected behavior** (validation/mutation/generation/background)
- [ ] **Resource state verification** (created/blocked/modified/generated as expected)
- [ ] **Error handling robustness** (failures produce clear, actionable messages)
- [ ] **Policy scope accuracy** (covers requested resources, excludes intended exceptions)

**SECURITY & RELIABILITY VERIFICATION:**
- [ ] **No false positives** (correct resources inappropriately affected)
- [ ] **No false negatives** (incorrect resources inappropriately allowed)
- [ ] **No bypass mechanisms** (overly permissive patterns, logic holes)
- [ ] **Performance acceptable** (policy doesn't significantly impact cluster operations)
- [ ] **Edge case handling** (empty values, null fields, malformed data)

### **STEP 6: MANDATORY CLEANUP & VERIFICATION** üßπ

**üö® CRITICAL: TESTING IS NOT COMPLETE UNTIL CLEANUP IS VERIFIED üö®**

**CLEANUP REQUIREMENTS:**
```bash
# 1. Remove ALL test namespaces
kubectl get namespaces | grep "test\|policy-test"
kubectl delete namespace <list-all-test-namespaces>

# 2. Remove ALL test files  
ls test-*.yaml 2>/dev/null && rm -f test-*.yaml
ls *test*.yaml 2>/dev/null && rm -f *test*.yaml

# 3. Verify cluster is clean
kubectl get all -A | grep -E "(test|policy-test)" || echo "‚úÖ Cluster clean"

# 4. Verify filesystem is clean  
ls test-* 2>/dev/null || echo "‚úÖ Files clean"
```

**CLEANUP VERIFICATION CHECKLIST:**
- [ ] **All test namespaces removed** (verified with `kubectl get namespaces`)
- [ ] **All test files removed** (verified with `ls test-*`)
- [ ] **No test resources in cluster** (verified with `kubectl get all -A | grep test`)
- [ ] **Cluster returned to original state** (no artifacts from testing remain)

**‚ùå DO NOT MARK TESTING COMPLETE WITHOUT CLEANUP VERIFICATION ‚ùå**

**If cleanup fails:**
- Document what couldn't be cleaned up and why
- Provide manual cleanup instructions for next operator
- Mark testing as "INCOMPLETE" until cleanup is resolved

## üö® UNIVERSAL TESTING ANTI-PATTERNS

**Policy-Type-Agnostic Mistakes:**
- ‚ùå **Testing only happy path** (works for validation, mutation, generation, background)
- ‚ùå **Assuming behavior without verification** (applies to all policy types)
- ‚ùå **Testing only popular resource types** (missing edge cases across all policies)
- ‚ùå **Not verifying actual state changes** (critical for mutation/generation policies)
- ‚ùå **Ignoring performance impact** (especially critical for background policies)
- ‚ùå **Skipping error condition testing** (essential for webhook/external policies)

**Logic & Pattern Mistakes:**
- ‚ùå **Overly permissive patterns** (`metadata.name: "?*"`, `spec: "?*"`)
- ‚ùå **Wrong field path assumptions** (not using `kubectl explain` to verify)
- ‚ùå **Incomplete array/list validation** (testing single items, ignoring edge cases)
- ‚ùå **Missing conditional branch testing** (testing only one path of if/then logic)
- ‚ùå **Placeholder patterns in production** (temporary patterns that become permanent)

**Resource & Scope Mistakes:**
- ‚ùå **Name-based resource discovery only** (missing capability-based discovery)
- ‚ùå **Single API group focus** (ignoring core K8s, CRDs, operators)
- ‚ùå **Namespace scope confusion** (not testing both namespaced and cluster resources)
- ‚ùå **Resource relationship ignorance** (not testing cross-resource impacts)

## üìã TESTING EXECUTION REQUIREMENTS

**When testing policies, follow this sequence:**
1. **Create test resources for positive cases** ‚Üí Verify they are created
2. **Create test resources for negative cases** ‚Üí Verify they are blocked  
3. **Check kubectl get commands** ‚Üí Confirm actual vs expected state
4. **Review error messages** ‚Üí Ensure they guide developers correctly
5. **Test edge cases** ‚Üí Boundary conditions and special scenarios
6. **üßπ MANDATORY CLEANUP** ‚Üí See STEP 6 above for detailed requirements

**‚ö†Ô∏è REMINDER: Steps 1-5 are testing. Step 6 is MANDATORY for completion.**

**Test Documentation Requirements:**
- Document what each test validates
- Show both the command and expected outcome
- Explain why each negative test should fail
- Provide clear success/failure criteria

## üéØ EXAMPLES: PROPER TESTING BY POLICY TYPE

### **Validation Policy Example (Image Security)**
```yaml
# Image security policy: no latest tags, must be from approved registry

‚úÖ POSITIVE TESTS:
- Pod with registry.company.com/app:v1.2.3 ‚Üí ALLOWED
- Deployment with registry.company.com/api:sha256:abc123 ‚Üí ALLOWED

‚ùå NEGATIVE TESTS:  
- Pod with ubuntu:latest ‚Üí BLOCKED
- Deployment with docker.io/app:v1.0 ‚Üí BLOCKED (wrong registry)
```

### **Mutation Policy Example (Resource Defaults)**
```yaml
# Mutation policy: add default resource limits if missing

‚úÖ MUTATION TESTS:
- Pod without limits ‚Üí VERIFY limits added (cpu: 100m, memory: 128Mi)
- Deployment with partial limits ‚Üí VERIFY only missing limits added
- Pod with existing limits ‚Üí VERIFY no changes made
```

### **Generation Policy Example (Service Mesh)**
```yaml
# Generate policy: create ServiceMonitor for services with monitoring=true

‚úÖ GENERATION TESTS:
- Service with monitoring=true ‚Üí VERIFY ServiceMonitor created
- Service without annotation ‚Üí VERIFY no ServiceMonitor created
- Delete Service ‚Üí VERIFY ServiceMonitor cleaned up
```

**UNIVERSAL PRINCIPLE**: Test that your policy does EXACTLY what it claims - no more, no less, regardless of policy type or resource.

## ‚ö†Ô∏è  CRITICAL VALIDATION LOGIC ERRORS TO AVOID

**These validation mistakes create security gaps:**

### üö® **Pattern Validation Errors**
- ‚ùå **Using `metadata.name: "?*"`** (allows everything with any name)
- ‚ùå **Overly permissive patterns** that don't actually restrict anything
- ‚ùå **Wrong field paths** (e.g., `spec.region` when it should be `spec.forProvider.region`)
- ‚ùå **Missing required fields** in validation patterns

### üö® **Logic Flow Errors**  
- ‚ùå **"Allow first, validate later"** approaches that create security holes
- ‚ùå **Changing deny rules to allow rules** without proper validation
- ‚ùå **Assuming validation works** without testing actual blocked resources
- ‚ùå **Placeholder patterns** meant for testing that remain in production policies

### üö® **Multi-Approach Validation Errors**
- ‚ùå **Different validation methods for similar resources** without testing both
- ‚ùå **Inconsistent security levels** between resource types
- ‚ùå **Missing validation** for some resource categories
- ‚ùå **Weak annotation-based controls** that can be easily bypassed

### ‚úÖ **CORRECT APPROACH: Validation Logic Verification**

Before finalizing any policy:
1. **List every validation pattern** used in your policy
2. **Test each pattern** with valid and invalid inputs  
3. **Verify field paths exist** in target resource schemas
4. **Confirm blocked resources are actually blocked**
5. **Ensure error messages guide users to correct solutions**

## üîí CRITICAL SECURITY ANTI-PATTERNS - NEVER DO THESE

**üö® SECURITY RULE #1: NEVER IGNORE RESOURCE TYPES WHEN USER REQUESTS "ALL"**
- ‚ùå **NEVER** create policies that ignore entire resource categories due to technical difficulties
- ‚ùå **NEVER** suggest "just skip ACK resources" or "just use Upbound resources" when user wants ALL
- ‚ùå **NEVER** create separate validation approaches for different providers without security justification

**üö® SECURITY RULE #2: NEVER CREATE ARBITRARY BYPASS PATTERNS**
- ‚ùå **NEVER** match on unrelated fields (e.g., `cidrBlocks: "?*"` for region validation)
- ‚ùå **NEVER** create "fallback allow" patterns that bypass the actual constraint
- ‚ùå **NEVER** use field existence as a proxy for compliance (e.g., "has description = compliant")

**üö® SECURITY RULE #3: EVERY VALIDATION PATTERN MUST ENFORCE THE ACTUAL CONSTRAINT**
- ‚úÖ **REQUIRE** that every anyPattern directly validates the user's constraint
- ‚úÖ **REQUIRE** that if a resource type can't be validated, it must be BLOCKED, not ignored
- ‚úÖ **REQUIRE** explicit documentation of why any resource type gets different treatment

**üö® WHEN ENCOUNTERING RESOURCE TYPES WITH DIFFERENT FIELD STRUCTURES:**
1. **Research the correct field structure** (annotations, status fields, etc.)
2. **Create appropriate validation for that structure** 
3. **If no validation is possible, BLOCK the resource type entirely**
4. **NEVER create fake validation patterns that don't actually enforce the constraint**

**Example of WRONG approach:**
```yaml
# ‚ùå WRONG: This allows ACK resources regardless of region
- spec:
    cidrBlocks: "?*"  # cidrBlocks has nothing to do with region!
```

**Example of CORRECT approach:**
```yaml
# ‚úÖ CORRECT: This validates ACK region annotation
- metadata:
    annotations:
      "services.k8s.aws/region": "us-east-1"
```

## üö´ ANTI-PATTERNS TO AVOID

**Never do these lazy behaviors:**
- ‚ùå Creating policies with "common" or "popular" resource subsets when user wants ALL
- ‚ùå Suggesting "this covers most use cases" when comprehensive coverage was requested  
- ‚ùå Making partial policies and waiting for user to notice gaps
- ‚ùå Using "efficient" shortcuts instead of complete enumeration
- ‚ùå Assuming 5-10 resource types are "sufficient" when 100+ exist
- ‚ùå Asking "do you want all or a subset?" when user already said ALL

**Security Bypass Mistakes:**
- ‚ùå **Creating validation patterns that don't validate the actual constraint**
- ‚ùå **Using unrelated field matches as proxies for compliance**
- ‚ùå **Allowing resource types through without proper validation due to technical difficulties**
- ‚ùå **Creating "ignore X resource type" patterns when user requested comprehensive coverage**

**When user says "ALL", "complete", "comprehensive", or "critical":**
- ‚úÖ Discover every single matching resource type
- ‚úÖ Include every resource in the policy immediately  
- ‚úÖ Validate 100% coverage before presenting results
- ‚úÖ Show exact counts and percentages
- ‚úÖ Fix gaps immediately without being asked

When creating Kyverno policies, follow these platform engineering principles:

## Policy Structure
- **ALWAYS create policies in the project root level `policies/` directory**
- Use descriptive names that explain the policy's purpose
- Include clear annotations for categorization and documentation
- Follow the naming pattern: `[action]-[resource]-[constraint]` (e.g., `disallow-latest-tag`, `require-resource-limits`)

## Policy Categories
- **Platform Security**: Image validation, RBAC enforcement, network policies
- **Platform Resources**: Resource limits, CPU/memory constraints, storage policies  
- **Platform Governance**: Label requirements, annotation enforcement, metadata validation

## Best Practices
- Always include both `validate` and `mutate` rules where appropriate
- Use `background: true` for policies that should run continuously
- Include proper failure messages that guide developers to fix issues
- Test policies with both positive and negative test cases
- Use `exclude` rules to avoid conflicts with system namespaces

## Example Policy Structure
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: policy-name
  annotations:
    policies.kyverno.io/category: Platform Security
    policies.kyverno.io/description: "Brief description of what this policy does"
spec:
  background: true
  rules:
  - name: rule-name
    match:
      resources:
        kinds:
        - Deployment
    validate:
      message: "Clear error message explaining the violation"
      pattern:
        # validation pattern here
```

## Common Policy Patterns

### Container Image Validation (Multiple Resource Types)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag
  annotations:
    policies.kyverno.io/category: Platform Security
spec:
  background: true
  rules:
  - name: check-image-tag-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
        - CronJob
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"
  - name: check-image-tag-pods
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          containers:
          - image: "!*:latest"
```

### Resource Limits (Dynamic Resource Discovery)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-resource-limits
  annotations:
    policies.kyverno.io/category: Platform Resources
spec:
  background: true
  rules:
  - name: check-resource-limits-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          template:
            spec:
              containers:
              - resources:
                  limits:
                    cpu: "?*"
                    memory: "?*"
  - name: check-resource-limits-cronjobs
    match:
      resources:
        kinds:
        - CronJob
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          jobTemplate:
            spec:
              template:
                spec:
                  containers:
                  - resources:
                      limits:
                        cpu: "?*"
                        memory: "?*"
```

### Universal Label Requirements (All Resources)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-required-labels
    match:
      resources:
        kinds:
        - "*"  # Apply to all resource types
    validate:
      message: "Required labels 'app' and 'environment' must be present"
      pattern:
        metadata:
          labels:
            app: "?*"
            environment: "?*"
```

### Custom Resource Policy Example
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: validate-custom-resource
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-custom-field
    match:
      resources:
        kinds:
        - serving.knative.dev/v1/Service  # Example: Knative Service
    validate:
      message: "Custom field validation failed"
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"  # Same validation for custom resources
```

## Testing Your Policies
Create test files in `tests/e2e/policies/` following this pattern:
```yaml
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: policy-name-test
spec:
  steps:
  - name: should-pass-valid-resource
    apply:
      file: valid-resource.yaml
  - name: should-fail-invalid-resource
    apply:
      file: invalid-resource.yaml
    assert:
      - file: expected-error.yaml
```

**Test Cleanup:**
- ALWAYS clean up test resources after testing
- Remove test namespaces: `kubectl delete namespace <test-namespace>`
- Remove test deployments: `kubectl delete deployment <test-deployment> -n <namespace>`
- Verify cleanup: `kubectl get all -n <test-namespace>`

**File Organization:**
- Policies: `policies/[policy-name].yaml`

## Dynamic Resource Discovery Commands

**üî• CRITICAL: Run discovery commands in PARALLEL for efficiency:**

```bash
# Discover all available resources in the cluster
kubectl api-resources --verbs=list -o name

# Get exact Kind names for policy creation
kubectl api-resources | grep "target-service" | awk '{print $NF}' | sort

# Count total resources for validation
kubectl api-resources | grep "target-service" | wc -l

# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -i storage
kubectl api-resources --verbs=list -o wide | grep -i network

# Check resource schemas for specific fields (run multiple in parallel)
kubectl explain deployment.spec.template.spec.containers &
kubectl explain service.spec.ports &
kubectl explain customresource.spec --recursive &

# Sample existing resources to understand field structures
kubectl get deployments -o yaml | head -50
kubectl get services -o yaml | head -50
kubectl get <custom-resource> -o yaml | head -50

# Validate field existence across multiple resource types (parallel)
kubectl explain resource1.spec.targetField --recursive | grep targetField &
kubectl explain resource2.spec.targetField --recursive | grep targetField &
kubectl explain resource3.spec.targetField --recursive | grep targetField &
wait  # Wait for all parallel commands to complete
```

**üìã DISCOVERY VALIDATION CHECKLIST:**
- [ ] Enumerated ALL resources of target type  
- [ ] Verified field structure for each resource type
- [ ] Counted total resources vs policy coverage
- [ ] Included both core and custom resources
- [ ] No lazy shortcuts or "common case" assumptions

## Policy Validation Commands
```bash
# Test a policy against a resource
kubectl apply -f your-policy.yaml
kubectl apply -f test-resource.yaml

# Check policy status
kubectl get clusterpolicies
kubectl describe clusterpolicy your-policy-name

# Validate policy syntax
kyverno validate policy your-policy.yaml

# Test policy against existing resources
kyverno apply your-policy.yaml --resource existing-resource.yaml

# Run Chainsaw tests
cd tests/e2e && chainsaw test policies/
```

Remember: Policies should enforce platform guardrails while providing clear guidance to developers on how to comply.

## üéØ FINAL VALIDATION BEFORE COMPLETION

Before presenting any policy to the user, ask yourself:

1. **Did I discover ALL matching resources?** (Not just common ones)
2. **Did I validate field structure for EVERY resource type?**  
3. **Does my policy coverage match the user's explicit request?**
4. **If user said "ALL" - did I include 100% of discovered resources?**
5. **Can I provide exact counts and percentages of coverage?**

**If ANY answer is "no" - FIX THE POLICY IMMEDIATELY. Don't wait for the user to catch your mistakes.**

**‚úÖ SUCCESS CRITERIA:**
- User said "ALL" ‚Üí Policy includes every matching resource (100% coverage)
- User said "comprehensive" ‚Üí No shortcuts, complete enumeration
- User said "critical" ‚Üí Bulletproof coverage, no gaps
- Policy ready ‚Üí Validated, tested, complete

## üéØ MANDATORY PRE-COMPLETION CHECKLIST

**Before presenting any policy as "complete," verify ALL of these:**

### **Policy Coverage Verification**
- [ ] Policy covers exact number of resources discovered (e.g., 131/131)
- [ ] No resource types were accidentally excluded
- [ ] All validation approaches are actually restrictive (not permissive)

### **Validation Logic Verification**  
- [ ] Every validation pattern has been tested with valid inputs ‚Üí PASS
- [ ] Every validation pattern has been tested with invalid inputs ‚Üí FAIL  
- [ ] Field paths are correct for each resource type (verified with `kubectl explain`)
- [ ] Error messages provide actionable guidance

### **Security Bypass Prevention**
- [ ] Every validation pattern directly enforces the user's specified constraint
- [ ] No arbitrary field matches used as proxies for actual validation
- [ ] No resource types get "free pass" due to technical implementation challenges
- [ ] If a resource type cannot be properly validated, it is explicitly BLOCKED rather than ignored

### **Test Case Completeness**
- [ ] Positive tests created for each validation approach
- [ ] Negative tests created for each validation approach  
- [ ] Resources in positive tests were actually created successfully
- [ ] Resources in negative tests were actually blocked (not created)
- [ ] Multiple resource types tested from each API group

### **Security Validation**
- [ ] No "allow everything" patterns (e.g., `metadata.name: "?*"`)
- [ ] No overly permissive validation that bypasses security controls
- [ ] Annotation-based validations require specific, verifiable values
- [ ] Deny conditions actually block resource creation when triggered

### **Documentation & Cleanup**
- [ ] Clear explanation of what each validation rule does
- [ ] Test results documented with actual kubectl commands and outputs
- [ ] **ALL test resources cleaned up from cluster** (STEP 6 completed)
- [ ] **Cleanup verification completed** (no test artifacts remain)
- [ ] Policy file saved in correct location (`policies/`)

**üö® CRITICAL: If ANY item above is unchecked, the policy is NOT ready for production.**

**‚ùì SELF-VERIFICATION QUESTIONS:**
1. "If I were an attacker, could I bypass any of these validation rules?"
2. "Do my test results prove the policy actually enforces what I claim?"
3. "Would a developer understand how to fix violations from the error messages?"
4. "Did I test the failure cases as thoroughly as the success cases?"
5. "Did I complete STEP 6 cleanup and verify no test artifacts remain?"
