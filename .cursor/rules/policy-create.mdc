# Kyverno Policy Creation Guidelines

**IMPORTANT: Before creating any policy, always ask the user ONE question at a time. Start with the first question and wait for the answer before proceeding to the next.**

**Agent Instructions: You MUST dynamically discover resources in the cluster based on the user's requirements. Use kubectl commands to find ALL available resources and check which ones have the relevant field structure. Do not make assumptions about what resources exist.**

**ALWAYS create validation policies only.**

**Ask these questions in order (one at a time):**

1. **"What specific behavior or constraint should this policy enforce?"** (What should it check for or prevent?)

2. **Dynamically discover and suggest relevant resources based on their requirement:**
   - **Analyze their constraint** to understand what field/capability they're targeting:
     - Container images → Look for resources with `.spec.containers[].image`, `.spec.template.spec.containers[].image`
     - Resource limits → Look for resources with `.spec.containers[].resources`, `.spec.template.spec.containers[].resources`
     - Labels/annotations → Look for resources with `.metadata.labels`, `.metadata.annotations`
     - Storage → Look for resources with `.spec.volumes`, `.spec.volumeClaimTemplates`, `.spec.persistentVolumeClaimRetentionPolicy`
     - Networking → Look for resources with `.spec.ports`, `.spec.selector`, `.spec.rules`
     - Security → Look for resources with `.spec.securityContext`, `.spec.serviceAccountName`, `.spec.imagePullSecrets`
     - Custom fields → Look for any field path they specify
   - **Query the cluster** to discover ALL available resources:
     ```bash
     kubectl api-resources --verbs=list -o name
     ```
   - **Programmatically check** which resources actually have the relevant field structure by sampling existing resources or checking OpenAPI schemas
   - **Present intelligent suggestions**: "Based on your requirement to enforce [X], I found these resources in your cluster that have the relevant field structure: [discovered list]. Should the policy target all of them or a subset?"
   - **Include both native and custom resources** (CRDs, operators, etc.) that match the field criteria

3. **"Are there any exceptions or special cases to consider?"** (Should it exclude certain namespaces, labels, etc.?)

**After Policy Creation:**
1. **ALWAYS ask: "Would you like to test the policy?"**
   - If yes, perform both positive and negative test cases
   - After testing, ALWAYS clean up test resources (namespaces, deployments, etc.)
   - Show clear test results and explain what was tested

When creating Kyverno policies, follow these platform engineering principles:

## Policy Structure
- **ALWAYS create policies in the project root level `policies/` directory**
- Use descriptive names that explain the policy's purpose
- Include clear annotations for categorization and documentation
- Follow the naming pattern: `[action]-[resource]-[constraint]` (e.g., `disallow-latest-tag`, `require-resource-limits`)

## Policy Categories
- **Platform Security**: Image validation, RBAC enforcement, network policies
- **Platform Resources**: Resource limits, CPU/memory constraints, storage policies  
- **Platform Governance**: Label requirements, annotation enforcement, metadata validation

## Best Practices
- Always include both `validate` and `mutate` rules where appropriate
- Use `background: true` for policies that should run continuously
- Include proper failure messages that guide developers to fix issues
- Test policies with both positive and negative test cases
- Use `exclude` rules to avoid conflicts with system namespaces

## Example Policy Structure
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: policy-name
  annotations:
    policies.kyverno.io/category: Platform Security
    policies.kyverno.io/description: "Brief description of what this policy does"
spec:
  background: true
  rules:
  - name: rule-name
    match:
      resources:
        kinds:
        - Deployment
    validate:
      message: "Clear error message explaining the violation"
      pattern:
        # validation pattern here
```

## Common Policy Patterns

### Container Image Validation (Multiple Resource Types)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag
  annotations:
    policies.kyverno.io/category: Platform Security
spec:
  background: true
  rules:
  - name: check-image-tag-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
        - CronJob
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"
  - name: check-image-tag-pods
    match:
      resources:
        kinds:
        - Pod
    validate:
      message: "Using 'latest' tag is not allowed. Please specify a version."
      pattern:
        spec:
          containers:
          - image: "!*:latest"
```

### Resource Limits (Dynamic Resource Discovery)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-resource-limits
  annotations:
    policies.kyverno.io/category: Platform Resources
spec:
  background: true
  rules:
  - name: check-resource-limits-workloads
    match:
      resources:
        kinds:
        - Deployment
        - DaemonSet
        - StatefulSet
        - Job
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          template:
            spec:
              containers:
              - resources:
                  limits:
                    cpu: "?*"
                    memory: "?*"
  - name: check-resource-limits-cronjobs
    match:
      resources:
        kinds:
        - CronJob
    validate:
      message: "CPU and memory limits are required for all containers"
      pattern:
        spec:
          jobTemplate:
            spec:
              template:
                spec:
                  containers:
                  - resources:
                      limits:
                        cpu: "?*"
                        memory: "?*"
```

### Universal Label Requirements (All Resources)
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-required-labels
    match:
      resources:
        kinds:
        - "*"  # Apply to all resource types
    validate:
      message: "Required labels 'app' and 'environment' must be present"
      pattern:
        metadata:
          labels:
            app: "?*"
            environment: "?*"
```

### Custom Resource Policy Example
```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: validate-custom-resource
  annotations:
    policies.kyverno.io/category: Platform Governance
spec:
  background: true
  rules:
  - name: check-custom-field
    match:
      resources:
        kinds:
        - serving.knative.dev/v1/Service  # Example: Knative Service
    validate:
      message: "Custom field validation failed"
      pattern:
        spec:
          template:
            spec:
              containers:
              - image: "!*:latest"  # Same validation for custom resources
```

## Testing Your Policies
Create test files in `tests/e2e/policies/` following this pattern:
```yaml
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: policy-name-test
spec:
  steps:
  - name: should-pass-valid-resource
    apply:
      file: valid-resource.yaml
  - name: should-fail-invalid-resource
    apply:
      file: invalid-resource.yaml
    assert:
      - file: expected-error.yaml
```

**Test Cleanup:**
- ALWAYS clean up test resources after testing
- Remove test namespaces: `kubectl delete namespace <test-namespace>`
- Remove test deployments: `kubectl delete deployment <test-deployment> -n <namespace>`
- Verify cleanup: `kubectl get all -n <test-namespace>`

**File Organization:**
- Policies: `policies/[policy-name].yaml`

## Dynamic Resource Discovery Commands
```bash
# Discover all available resources in the cluster
kubectl api-resources --verbs=list -o name

# Find resources with specific capabilities
kubectl api-resources --verbs=list -o wide | grep -i storage
kubectl api-resources --verbs=list -o wide | grep -i network

# Check resource schemas for specific fields
kubectl explain deployment.spec.template.spec.containers
kubectl explain service.spec.ports
kubectl explain customresource.spec --recursive

# Sample existing resources to understand field structures
kubectl get deployments -o yaml | head -50
kubectl get services -o yaml | head -50
kubectl get <custom-resource> -o yaml | head -50
```

## Policy Validation Commands
```bash
# Test a policy against a resource
kubectl apply -f your-policy.yaml
kubectl apply -f test-resource.yaml

# Check policy status
kubectl get clusterpolicies
kubectl describe clusterpolicy your-policy-name

# Validate policy syntax
kyverno validate policy your-policy.yaml

# Test policy against existing resources
kyverno apply your-policy.yaml --resource existing-resource.yaml

# Run Chainsaw tests
cd tests/e2e && chainsaw test policies/
```

Remember: Policies should enforce platform guardrails while providing clear guidance to developers on how to comply.
description:
globs:
alwaysApply: false
---
